<!-- GFM-TOC -->
* [第1章 开始启程—你的第一行Android代码](#第1章-开始启程你的第一行android代码)
    * [1.1 了解全貌—Android王国简介](#11-了解全貌android王国简介)
    * [1.2 手把手带你搭建开发环境](#12-手把手带你搭建开发环境)
    * [1.3创建你的第一个Android项目](#13-创建你的第一个android项目)
    * [1.4 前行必备—掌握日志工具的使用](#14-前行必备掌握日志工具的使用)
    * [1.5 小结与点评](#15-小结与点评)
* [第2章 先从看得到的入手—探究活动](#第2章-先从看得到的入手探究活动)
    * [2.1 活动是什么](2.1活动是什么)
    * [2.2 活动的基本用法](2.2活动的基本用法)
    * [2.3 使用Intent在活动之间穿梭](2.3使用Intent在活动之间穿梭)
    * [2.4 活动的生命周期](2.4活动的生命周期)
    * [2.5 活动的启动模式](2.5活动的启动模式)
    * [2.6 活动的最佳实践](2.6活动的最佳实践)
    * [2.7 小结与点评](2.7小结与点评)
* [第3章 软件也要拼脸蛋——UI开发的点点滴滴](第3章软件也要拼脸蛋——UI开发的点点滴滴)
    * [3.1 如何编写程序界面](3.1如何编写程序界面)
    * [3.2 常用控件的使用方法](3.2常用控件的使用方法)
    * [3.3 详解4中基本布局](3.3详解4中基本布局)
    * [3.4 系统控件不够用？创建自定义控件](3.4系统控件不够用？创建自定义控件)
    * [3.5 最常用和最难用的控件——ListView](3.5最常用和最难用的控件——ListView)
    * [3.6 更强大的滚动控件——RecyclerView](3.6更强大的滚动控件——RecyclerView)
    * [3.7 编写界面的最佳实践](3.7编写界面的最佳实践)
    * [3.8 小结与点评](3.8小结与点评)
* [第4章 手机平板要兼顾——探究碎片](第4章手机平板要兼顾——探究碎片)
    * [4.1 碎片是什么](4.1碎片是什么)
    * [4.2 碎片的使用方式](4.2碎片的使用方式)
    * [4.3 碎片的生命周期](4.3碎片的生命周期)
    * [4.4 动态加载布局的技巧](4.4动态加载布局的技巧)
    * [4.5 碎片的最佳实践——一个简易版的新闻应用](4.5碎片的最佳实践——一个简易版的新闻应用)
    * [4.6 小结与点评](4.6小结与点评)
* [第5章 全局大喇叭——详解广播机制](第5章全局大喇叭——详解广播机制)
    * [5.1 广播机制简介](5.1广播机制简介)
    * [5.2 接收系统广播](5.2接收系统广播)
    * [5.3 发送自定义广播](5.3发送自定义广播)
    * [5.4 使用本地广播](5.4使用本地广播)
    * [5.5 广播的最佳实践——实现强制下线功能](5.5广播的最佳实践——实现强制下线功能)
    * [5.6 小结与点评](5.6小结与点评)
* [第6章 数据存储全方案——详解持久化技术](第6章数据存储全方案——详解持久化技术)
    * [6.1 持久化技术简介](6.1持久化技术简介)
    * [6.2 文件存储](6.2文件存储)
    * [6.3 SharedPreference存储](6.3SharedPreference存储)
    * [6.4 SQLite数据库存储](6.4SQLite数据库存储)
    * [6.5 使用LitePal操作数据库](6.5使用LitePal操作数据库)
    * [6.6 小结与点评](6.6小结与点评)
* [第7章 跨程序共享数据——探究内容提供器](第7章跨程序共享数据——探究内容提供器)
    * [7.1 内容提供器简介](7.1内容提供器简介)
    * [7.2 运行时权限](7.2运行时权限)
    * [7.3 访问其他程序中的数据](7.3访问其他程序中的数据)
    * [7.4 创建自己的内容提供器](7.4创建自己的内容提供器)
    * [7.5 Git时间——版本控制工具进阶](7.5Git实践——版本控制工具进阶)
    * [7.6 小结与点评](7.6小结与点评)
* [第8章 丰富你的程序——运用手机多媒体](第8章丰富你的程序——运用手机多媒体)
    * [8.1 将程序运行到手机上](8.1将程序运行到手机上)
    * [8.2 使用通知](8.2使用通知)
    * [8.3 调用摄像头和相册](8.3调用摄像头和相册)
    * [8.4 播放多媒体文件](8.4播放多媒体文件)
    * [8.5 小结与点评](8.5小结与点评)
* [第9章 看看精彩的世界——使用网络技术](第9章看看精彩的世界——使用网络技术)
    * [9.1 WebView的用法](9.1WebView的用法)
    * [9.2 使用HTTP协议访问网络](9.2使用HTTP协议访问网络)
    * [9.3 解析XML格式数据](9.3解析XML格式数据)
    * [9.4 解析JSON格式数据](9.4解析JSON格式数据)
    * [9.5 网络编程的最佳实践](9.5网络编程的最佳实践)
    * [9.6 小结与点评](9.6小结与点评)
* [第10章 后台默默的劳动者——探究服务](第10章后台默默的劳动者——探究服务)
    * [10.1 服务是什么](10.1服务是什么)
    * [10.2 Android多线程编程](10.2Android多线程编程)
    * [10.3 服务的基本用法](10.3服务的基本用法)
    * [10.4 服务的生命周期](10.4服务的生命周期)
    * [10.5 服务的更多技巧](10.5服务的更多技巧)
    * [10.6 服务的最佳实践——完整版的下载示例](10.6服务的最佳实践——完整版的下载示例)
    * [10.7 小结与点评](10.7小结与点评)
* [第11章 Android特色开发——基于位置的服务](第11章Android特色开发——基于位置的服务)
    * [11.1 基于位置的服务简介](11.1基于位置的服务简介)
    * [11.2 申请API Key](11.2申请APIKey)
    * [11.3 使用百度定位](11.3使用百度定位)
    * [11.4 使用百度地图](11.4使用百度地图)
    * [11.5 Git时间——版本控制工具的高级用法](11.5Git时间——版本控制工具的高级用法)
    * [11.6 小结与点评](11.6小结与点评)
* [第12章 最佳的UI体验——MaterialDesign实战](第12章最佳的UI体验——MaterialDesign实战)
    * [12.1 什么是Material Design](12.1什么是MaterialDesign)
    * [12.2 Toolbar](12.2Toolbar)
    * [12.3 滑动菜单](12.3滑动菜单)
    * [12.4 悬浮按钮和可交互提示](12.4悬浮按钮和可交互提示)
    * [12.5 卡片式布局](12.5卡片式布局)
    * [12.6 下拉刷新](12.6下拉刷新)
    * [12.7 可折叠式标题栏](12.7可折叠式标题栏)
    * [12.8 小结与点评](12.8小结与点评)
* [第13章 继续进阶——你还应该掌握的高级技巧](第13章继续进阶——你还应该掌握的高级技巧)
    * [13.1 全局获取Context的技巧](13.1全局获取Context的技巧)
    * [13.2 使用Intent传递对象](13.2使用Intent传递对象)
    * [13.3 定制自己的日志工具](13.3定制自己的日志工具)
    * [13.4 调试Android程序](13.4调试Android程序)
    * [13.5 创建定时任务](13.5创建定时任务)
    * [13.6 多窗口模式编程](13.6多窗口模式编程)
    * [13.7 Lambda表达式](13.7Lambda表达式)
    * [13.8 总结](13.8总结)
* [第14章 进入实战——开发酷欧天气](第14章进入实战——开发酷欧天气)
    * [14.1 功能需求及技术可行性分析](14.1功能需求及技术可行性分析)
    * [14.2 Git时间——将代码托管到Github上](14.2Git时间——将代码托管到Github上)
    * [14.3 创建数据库和表](14.3创建数据库和表)
    * [14.4 遍历全国省市县数据](14.4遍历全国省市县数据)
    * [14.5 显示天气信息](14.5显示天气信息)
    * [14.6 手动更新天气和切换城市](14.6手动更新天气和切换城市)
    * [14.7 后台自动更新天气](14.7后台自动更新天气)
    * [14.8 修改图标和名称](14.8修改图标和名称)
    * [14.9 你还可以做的事情](14.9你还可以做的事情)
* [第15章 最后一步——将应用发布到360应用商店](第15章最后一步——将应用发布到360应用商店)
    * [15.1 生成正式签名的APK文件](15.1生成正式签名的APK文件)
    * [15.2 申请360开发者账号](15.2申请360开发者账号)
    * [15.3 发布应用程序](15.3发布应用程序)
    * [15.4 嵌入广告进行盈利](15.4嵌入广告进行盈利)
    * [15.5 结束语](15.5结束语)
* [参考资料](#参考资料)
<!-- GFM-TOC -->

# 第1章 开始启程—你的第一行Android代码

2003年10月，Andy Rubin等人创办了Android公司，2005年8月谷歌收购了这家仅仅成立了22个月的公司，并让Andy Rubin继续负责Android项目。2008年谷歌推出了Android系统的第一个版本。

由于谷歌的开发政策，任何手机厂商和个人都能免费获取到Android操作系统的源码，并且可以自由地使用和定制。

## 1.1 了解全貌—Android王国简介

### 1.1.1 Android 系统架构

Android大致可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。

1.Linux内核层

Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。

2.系统运行库层

这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGl|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。

同样这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机示例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。

3.应用框架层

这一层主要提供了构建应用程序时可能用到的各种API,Andorid自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。

4.应用层

所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。

![image](https://developer.android.com/guide/platform/images/android-stack_2x.png)

### 1.1.2 Android 已发布的版本

2008年9月，谷歌正式发布了Android 1.0系统。2011年2月，谷歌发布了Android 3.0系统，这个系统是专门为平板电脑设计的，但也是Android为数不多的比较失败的版本，同年10月，谷歌又发布了Android 4.0系统。2014年Google I/O大会上，谷歌推出了号称史上版本改动最大的Android 5.0系统，其中使用了ART运行环境替代了Dalvik虚拟机，大大提升了应用的运行速度，还提出了Material Design的概念来优化应用的界面设计。除此之外，还推出了Android Wear、Android Auto、Android TV系统，从而进军可穿戴设备、汽车、电视等全新领域。2015年Google I/O大会推出了Android 6.0系统，加入运行时权限功能。2016年Google I/O大会上推出了Android 7.0系统，加入多窗口模式功能。

### 1.1.3 Android应用开发特色

Android系统提供了一些东西供我们开发出优秀的应用程序。

1.四大组件

Android系统四大组件分别是活动(Activity)、服务(Service)、广播接收器(Broadcast Receiver)、内容提供器(Content Provider)。其中活动是所以Android应用程序的门面，凡是在应用程序中你看得到的东西，都是放在活动中的。而服务就比较低调了，你无法看到它，但它会一直在后台默默地运行，即使用户退出了应用，服务仍然是可以继续运行的。广播接收器允许你的应用接收来自各处的广播消息，比如电话、短信等，你也可以向外发出广播信息。内容提供器为应用程序之间提供共享数据，比如可以用它读取系统电话簿中的联系人。

2.丰富的系统控件

Android系统提供了丰富的系统控件，并且你也可以进行自定义控件。

3.SQLite数据库

Android系统还自带了这种轻量级、运行速度极快的嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变得非常方便。

4.强大的多媒体

如音乐、视频、录音、拍照、闹铃等等，这一切你都可以在程序中通过代码进行控制。

5.地理位置定位

现在的Android手机都内置有GPS，如果结合功能强大的地图功能，LBS这一领域潜力无限。

## 1.2 手把手带你搭建开发环境

### 1.2.1 准备所需要的工具

- JDK。JDK是Java语言的软件开发工具包，它包含了Java的运行环境、工具集合、基础类库等内容。
- Android SDK。Android SDK是谷歌提供的Android开发工具包，在开发Android程序时，需引入它使用Android相关API。
- Android Studio。它是谷歌在2013年推出的官方IDE工具，比起在Eclipse上安装ADT插件来开发Android程序，Android Studio则是专业的Android开发IDE。

### 1.2.2 搭建开发环境

直接到Android官网下载最新开发工具即可，如果没翻墙，可以去这个地址下载：
[百度云下载](https://pan.baidu.com/s/1nuABMDb)

安装Android Studio时只需一直Next，在INstall Type时选择Standard类型，再一直Next，点击Finish，配置就完成了。最后等待Android Studio联网下载更新完成就会进入Android Studio的欢迎界面。

## 1.3 创建你的第一个Android项目

### 1.3.1 创建HellowWorld项目

在欢迎界面点击Start a new Android Studio project，会打开一个创建新项目的界面。对应的属性信息如下：

- Application name。应用名称。
- Company Domain。公司域名。
- Package name。项目的包名。Android系统通过包名来区分程序，需保证其唯一性。Android Studio会根据应用名称和公司域名来自动生成合适的包名，你也可以点击右侧的Edit自行修改。
- Project location。项目代码存放的位置。

接下来点击Next即对项目的最低兼容版本进行配置。

- Minimum SDK。最小SDK版本，一般指定为API 19即可，想要兼容更低的设备，指定为API 15。
- Wear、TV、Android Auto。分别对应可穿戴设备、电视、汽车程序。

接下来点击Next选择内置的模板-Empty Activity即可。

继续点击Next，可以给创建的活动和布局命名。

- Activity Name。活动名称，命名规范为HelloWorldActivity。
- Layout Name。布局名称，命名规范为activity_hello_world。

最后，点击Finish，项目创建成功。

### 1.3.2 启动模拟器

观察Android Studio顶部工具栏中的图标，找到名称为AVD Mangaer的手机图标区域(右下方有个安卓机器人),点击会弹出虚拟设备列表弹框，在下方点击Create Virtual Device安卓即可进入Select HardWare界面，这里有很多设备可供我们选择，除了创建手机模拟器，还可以创建平板、手表、电视模拟器。选择你想要的设备和最新的Android系统版本，指定或不指定其它的信息(模拟器名字、分辨率、横竖屏等等)之后,点Finish即可在模拟器列表中看到一个创建好的模拟器设备了，点击三角形启动按钮即可启动模拟器。

### 1.3.3 运行HelloWorld

观察Android Studio顶部工具栏中的图标，如下图所示。其中左边的锤子是用来编译项目的，中间的下拉列表是用来选择运行哪一个项目的，通常app就是当前的主项目，右边的三角形按钮时用来运行项目的。

![image](https://s1.ax1x.com/2018/08/13/PgncxP.png)

点击中间按钮，选择刚刚刚刚创建好的虚拟设备即可运行该应用。

### 1.3.4分析你的第一个Android程序

项目的结构列表位于最左边，刚创建的新项目默认使用Android模式的项目结构，但这并不是真实的目录结构，是为了快速开发而设置的，点击结构列表上面的下拉列表，选择Proejct，即看到真实的目录结构。

![image](https://s1.ax1x.com/2018/08/13/Pgumid.png)

1..gradle和.idea

自动生成的文件，不管它。

2.app

项目的代码、资源目录，开发工作基本在此目录下进行。

3.build

主要包含了一些在编译时自动生成的文件。

4.gradle

目录下包含了gralde wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认不启动gradle wrapper的方式，可以点击AS导航栏->File->Settings->Build,Execution,Deployment->Gradle进行配置更改。

5..gitignore

将指定的目录或文件排除在版本控制之外。

6.build.gradle

项目全局的gradle构建脚本。

7.gradle.properties

这个文件时全局的gradle配置文件，配置的属性会影响项目所有的gradle编译脚本。

8.gradle和gradlew.bat

用来在命令行界面中执行gradle命令，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。

9.HelloWorld.iml

iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件(Android Studio基于IntelliJ IDEA),用于标识这是一个IntelliJ IDEA项目。

10.local.properties

用于指定本机中的SDK和NDK路径，自动生成，如果SDK/NDK位置发生改变，改成新位置即可。

11.settings.gradle

用于指定项目中所有引入的模块。一般都是自动引入。

接下来详细分析app目录，因为大部分的开发工作在此目录下。

![image](https://s1.ax1x.com/2018/08/13/PgM2Kx.png)

1.build

与外层的build目录类型，包含编译时自动生成的文件。

2.libs

用于存放第三方jar包，其会被自动添加到构建路径中去。

3.androidTest

用来编写Android Test测试用例的，可以对项目进行一些自动化测试。

4.java

放置Java代码的地方。

5.res

用于存放图片、布局、字符串等资源。比如说，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下。

6.AndroidManifest.xml

整个项目的配置文件，用于定义四大组件和添加静态权限声明。

7.test

用来编写Unit Test测试用例。

8..gitignore

和外层.gitignore文件类似。

9.app.iml

和外层app.iml文件类似。

10.build.gradle

app模块的gradle构建脚本，其中会指定很多项目构建相关的配置。

11.proguard-rules.pro

用于指定代码的混淆规则，混淆会使破解者难以阅读反编译的代码。

接下来分析项目如何运行起来。

![image](https://s1.ax1x.com/2018/08/13/PgQWSs.png)

这段代码表示对SplashActivity这个活动进行注册，没有在AndroidManifest.xml里注册的活动是不能使用的。其中intent-filter里的两行代码非常重要:

    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
    
这表示了SplashActivity是这个项目的主活动，即应用程序的入口。

打开HelloWorldActivity，它是继承自AppCompatActivity的，这是一种向下兼容的Acitivity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android 2.1系统。Activity是系统提供的一个活动基类，必须继承它或者它的子类才能拥有活动的特性(AppCompatActivity是Activity的子类)。

Android程序设计为逻辑和视图分离，因此使用setContentView()的方式将对应的布局引进来。

### 1.3.5 详解项目中的资源

- drawable。所有以drawable开头的文件夹用来存放图片。
- mipmap。所有mipmap开头的文件夹用来存放应用图标。
- values。所有已values开头的文件夹用来存放字符串、样式、颜色等配置。
- layout。用来存放布局文件。

其中mipmap会有hdpi、xhdpi、xxhdpi等后缀，是为了适配屏幕的分辨率，从而更好地兼容各种设备，一般放在mipmap-xxhdpi下就可以了。

res/values/strings.xml文件下

    <string name="app_name">HelloWorld</string>
    
引用该字符串有两种方式：

- 代码中使用R.string.helloworld。
- XML中使用@string/hello_world。

drawble、mipmap、layout的引用与其类似。

打开AndroidManifest.xml，其中：

    android:icon="..."
    android:label="..."
    
可以看到就是使用上面的第二种引用形式来指定了项目的应用图标和应用的名称。

### 1.3.6 详解build.gradle文件

Gradle基于Groovy的领域特定语言(DSL)来声明项目设置。

打开工程目录下的build.gradle，其中两处repositories的闭包中都声明了jcenter()这行配置，它是一个代码托管仓库，声明它以后，就可以在项目中轻松引用任何jcenter上的开源项目了。

接下来，dependencies闭包使用了classpath声明了一个Gradle插件。声明它，AS才能使用Gradle构建Android项目，最后面试版本号，最新为3.2.0。

下面再来分析一下app目录下的build.gradle文件，第一行有两种值可选：

- com.android.application。表示这是一个应用程序模块。
- com.android.library。表示这是一个库模块。

区别为：应用程序可以直接运行，库模块智能作为代码块依附在别的应用程序模块来运行。

接下来是一个大的android闭包，用于配置项目构建的各种属性。

- compileSdkVersion。用于指定项目的编译版本。
- buildToolsVersion。用于指定项目构建工具的版本。

然后，在andorid闭包中又嵌套了一个defaultConfig闭包。

- applicaitonId。指定项目的包名。
- minSdkVersion。指定项目最低兼容的Android系统版本。
- tartgetSdkVersion。指定的值表示你在该目标版本上已经做了充分的测试，系统将会为你的应用程序启动一些最新的功能和特性。
- versionCode。指定项目的版本号。
- versionName。指定项目的版本名。

接下来，看buildTypes闭包。

- debug子闭包。指定生成测试版安装文件的配置。
- release子闭包。指定生成正式版安装文件的配置。

子闭包中。

- minifyEnabled。指定是否对项目的代码进行混淆。
- proguardFiles。指定混淆时使用的规则文件，这里指定了两个文件。
    
    1.proguard-android.txt。在Android SDK下，所有项目通用的混淆规则。
    2.proguard-rules.pro。在当前项目的根目录下，用于编写特有的混淆规则。

注意：直接运行项目生产的都是测试版安装文件。

最后，则是dependencies闭包，用于指定当前项目所有的依赖关系。通常有3钟依赖方式：

- 本地依赖。第一行的implementation fileTree就是一个本地依赖声明，表示将libs目录下的所有.jar后缀的文件都添加到项目的构建路径当中。
- 远程依赖。第二行的implementation则是远程依赖声明，其中com.android.support是域名部分，用于和其他公司的库做区分；appcompat-v7是组名称，用于和同一个公司中不同的库做区分；27.0.0是版本号，用于和同一个库中不同的版本做区分。声明后，Gradle会在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有则会自动联网下载，然后在添加到项目的构建目录当中。
- 库依赖。新建项目默认没有这个依赖，要使用它，需要创建一个和app模块的同级模块/库,然后在使用格式compile project(':helper')，即为依赖了创建的helper库。

## 1.4 前行必备—掌握日志工具的使用

### 1.4.1 使用Android的日志工具Log

Android的日志工具类是Log(android.util.log)。

- Log.v()。打印最为琐碎的信息，对应级别为verbose，级别最低。
- Log.d()。打印调试信息，对应级别debug，比verbose高一级。
- Log.i()。打印重要信息，对应级别info，比debug高一级。
- Log.w()。打印警告信息，对应级别warn，比info高一级。
- Log.e()。打印错误信息，对应解绑error，比warn高一级。

    Log.d("HelloWorldActivity", "onCreate execute")；
    
Log.d()方法有两个参数，第一个是tag，一般传入当前的类名，主要对打印信息进行过滤；第二个是msg，即想要打印的具体内容。

### 1.4.2 为什么使用Log而不使用System.out

与Log相比，System.out的缺点如下：

- 日志打印不可控制。
- 打印时间无法控制。
- 不能添加过滤器。
- 日志没有级别区分。

Log可以使用logd快速生成模块代码，并且，在方法外面输入logt可生成tag。

除了快捷键，logcat中还能轻松添加过滤器。

- Show only selected application。只显示当前选中程序的日志。
- Firebase。谷歌的一个分析工具。
- No Filters。没有过滤器。
- Edit Filter Configuration。可以自定义过滤器，比如在log Tag一栏中填入data，一次过滤出log Tag为data的数据。

日志级别控制的好处：可以很快地找到你所关心的日志。

最后，其实我用的最多的还是关键字过滤，并且它支持正则表达式。

## 1.5 小结与点评

本章我们认识了Android系统，搭建了开发环境，并且创建了自己的第一个Android项目，对AS的目录结构和执行过程有了一定的认识，最后，学习了日志工具的使用，your are so good！

# 第2章 先从看得到的入手—探究活动

