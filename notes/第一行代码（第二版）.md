    <!-- GFM-TOC -->
* [一、开始启程—你的第一行Android代码](#一开始启程你的第一行android代码)
* [二、先从看得到的入手—探究活动](#二先从看得到的入手探究活动)
* [三、数据存储全方案——详解持久化技术](#三数据存储全方案详解持久化技术)
* [四、跨程序共享数据——探究内容提供器](#四跨程序共享数据探究内容提供器)
* [五、丰富你的程序——运用手机多媒体](八丰富你的程序——运用手机多媒体)
* [六、看看精彩的世界——使用网络技术](九看看精彩的世界——使用网络技术)
* [七、后台默默的劳动者——探究服务](十、后台默默的劳动者——探究服务)
* [八、Android特色开发——基于位置的服务](十一Android特色开发——基于位置的服务)
* [九、最佳的UI体验——MaterialDesign实战](#十二最佳的UI体验——MaterialDesign实战)
* [十、继续进阶——你还应该掌握的高级技巧](十三继续进阶——你还应该掌握的高级技巧)
* [十一、进入实战——开发酷欧天气](十四进入实战——开发酷欧天气)
* [十二、最后一步——将应用发布到360应用商店](十五最后一步——将应用发布到360应用商店)
* [参考资料](#参考资料)
<!-- GFM-TOC -->

# 一、开始启程—你的第一行Android代码

2003年10月，Andy Rubin等人创办了Android公司，2005年8月谷歌收购了这家仅仅成立了22个月的公司，并让Andy Rubin继续负责Android项目。2008年谷歌推出了Android系统的第一个版本。

由于谷歌的开发政策，任何手机厂商和个人都能免费获取到Android操作系统的源码，并且可以自由地使用和定制。

## 了解全貌—Android王国简介

### Android 系统架构

Android大致可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。

1.Linux内核层

Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。

2.系统运行库层

这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGl|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。

同样这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用。另外，Android运行库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机示例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。

3.应用框架层

这一层主要提供了构建应用程序时可能用到的各种API,Andorid自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。

4.应用层

所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从Google Play上下载的小游戏，当然还包括你自己开发的程序。

![image](https://developer.android.com/guide/platform/images/android-stack_2x.png)

### Android 已发布的版本

2008年9月，谷歌正式发布了Android 1.0系统。2011年2月，谷歌发布了Android 3.0系统，这个系统是专门为平板电脑设计的，但也是Android为数不多的比较失败的版本，同年10月，谷歌又发布了Android 4.0系统。2014年Google I/O大会上，谷歌推出了号称史上版本改动最大的Android 5.0系统，其中使用了ART运行环境替代了Dalvik虚拟机，大大提升了应用的运行速度，还提出了Material Design的概念来优化应用的界面设计。除此之外，还推出了Android Wear、Android Auto、Android TV系统，从而进军可穿戴设备、汽车、电视等全新领域。2015年Google I/O大会推出了Android 6.0系统，加入运行时权限功能。2016年Google I/O大会上推出了Android 7.0系统，加入多窗口模式功能。

### Android应用开发特色

Android系统提供了一些东西供我们开发出优秀的应用程序。

1.四大组件

Android系统四大组件分别是活动(Activity)、服务(Service)、广播接收器(Broadcast Receiver)、内容提供器(Content Provider)。其中活动是所以Android应用程序的门面，凡是在应用程序中你看得到的东西，都是放在活动中的。而服务就比较低调了，你无法看到它，但它会一直在后台默默地运行，即使用户退出了应用，服务仍然是可以继续运行的。广播接收器允许你的应用接收来自各处的广播消息，比如电话、短信等，你也可以向外发出广播信息。内容提供器为应用程序之间提供共享数据，比如可以用它读取系统电话簿中的联系人。

2.丰富的系统控件

Android系统提供了丰富的系统控件，并且你也可以进行自定义控件。

3.SQLite数据库

Android系统还自带了这种轻量级、运行速度极快的嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变得非常方便。

4.强大的多媒体

如音乐、视频、录音、拍照、闹铃等等，这一切你都可以在程序中通过代码进行控制。

5.地理位置定位

现在的Android手机都内置有GPS，如果结合功能强大的地图功能，LBS这一领域潜力无限。

## 手把手带你搭建开发环境

### 准备所需要的工具

- JDK。JDK是Java语言的软件开发工具包，它包含了Java的运行环境、工具集合、基础类库等内容。
- Android SDK。Android SDK是谷歌提供的Android开发工具包，在开发Android程序时，需引入它使用Android相关API。
- Android Studio。它是谷歌在2013年推出的官方IDE工具，比起在Eclipse上安装ADT插件来开发Android程序，Android Studio则是专业的Android开发IDE。

### 搭建开发环境

直接到Android官网下载最新开发工具即可，如果没翻墙，可以去这个地址下载：
[百度云下载](https://pan.baidu.com/s/1nuABMDb)

安装Android Studio时只需一直Next，在INstall Type时选择Standard类型，再一直Next，点击Finish，配置就完成了。最后等待Android Studio联网下载更新完成就会进入Android Studio的欢迎界面。

## 创建你的第一个Android项目

### 创建HellowWorld项目

在欢迎界面点击Start a new Android Studio project，会打开一个创建新项目的界面。对应的属性信息如下：

- Application name。应用名称。
- Company Domain。公司域名。
- Package name。项目的包名。Android系统通过包名来区分程序，需保证其唯一性。Android Studio会根据应用名称和公司域名来自动生成合适的包名，你也可以点击右侧的Edit自行修改。
- Project location。项目代码存放的位置。

接下来点击Next即对项目的最低兼容版本进行配置。

- Minimum SDK。最小SDK版本，一般指定为API 19即可，想要兼容更低的设备，指定为API 15。
- Wear、TV、Android Auto。分别对应可穿戴设备、电视、汽车程序。

接下来点击Next选择内置的模板-Empty Activity即可。

继续点击Next，可以给创建的活动和布局命名。

- Activity Name。活动名称，命名规范为HelloWorldActivity。
- Layout Name。布局名称，命名规范为activity_hello_world。

最后，点击Finish，项目创建成功。

### 启动模拟器

观察Android Studio顶部工具栏中的图标，找到名称为AVD Mangaer的手机图标区域(右下方有个安卓机器人),点击会弹出虚拟设备列表弹框，在下方点击Create Virtual Device安卓即可进入Select HardWare界面，这里有很多设备可供我们选择，除了创建手机模拟器，还可以创建平板、手表、电视模拟器。选择你想要的设备和最新的Android系统版本，指定或不指定其它的信息(模拟器名字、分辨率、横竖屏等等)之后,点Finish即可在模拟器列表中看到一个创建好的模拟器设备了，点击三角形启动按钮即可启动模拟器。

### 运行HelloWorld

观察Android Studio顶部工具栏中的图标，如下图所示。其中左边的锤子是用来编译项目的，中间的下拉列表是用来选择运行哪一个项目的，通常app就是当前的主项目，右边的三角形按钮时用来运行项目的。

![image](https://s1.ax1x.com/2018/08/13/PgncxP.png)

点击中间按钮，选择刚刚刚刚创建好的虚拟设备即可运行该应用。

### 分析你的第一个Android程序

项目的结构列表位于最左边，刚创建的新项目默认使用Android模式的项目结构，但这并不是真实的目录结构，是为了快速开发而设置的，点击结构列表上面的下拉列表，选择Proejct，即看到真实的目录结构。

![image](https://s1.ax1x.com/2018/08/13/Pgumid.png)

1..gradle和.idea

自动生成的文件，不管它。

2.app

项目的代码、资源目录，开发工作基本在此目录下进行。

3.build

主要包含了一些在编译时自动生成的文件。

4.gradle

目录下包含了gralde wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认不启动gradle wrapper的方式，可以点击AS导航栏->File->Settings->Build,Execution,Deployment->Gradle进行配置更改。

5..gitignore

将指定的目录或文件排除在版本控制之外。

6.build.gradle

项目全局的gradle构建脚本。

7.gradle.properties

这个文件时全局的gradle配置文件，配置的属性会影响项目所有的gradle编译脚本。

8.gradle和gradlew.bat

用来在命令行界面中执行gradle命令，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。

9.HelloWorld.iml

iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件(Android Studio基于IntelliJ IDEA),用于标识这是一个IntelliJ IDEA项目。

10.local.properties

用于指定本机中的SDK和NDK路径，自动生成，如果SDK/NDK位置发生改变，改成新位置即可。

11.settings.gradle

用于指定项目中所有引入的模块。一般都是自动引入。

接下来详细分析app目录，因为大部分的开发工作在此目录下。

![image](https://s1.ax1x.com/2018/08/13/PgM2Kx.png)

1.build

与外层的build目录类型，包含编译时自动生成的文件。

2.libs

用于存放第三方jar包，其会被自动添加到构建路径中去。

3.androidTest

用来编写Android Test测试用例的，可以对项目进行一些自动化测试。

4.java

放置Java代码的地方。

5.res

用于存放图片、布局、字符串等资源。比如说，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下。

6.AndroidManifest.xml

整个项目的配置文件，用于定义四大组件和添加静态权限声明。

7.test

用来编写Unit Test测试用例。

8..gitignore

和外层.gitignore文件类似。

9.app.iml

和外层app.iml文件类似。

10.build.gradle

app模块的gradle构建脚本，其中会指定很多项目构建相关的配置。

11.proguard-rules.pro

用于指定代码的混淆规则，混淆会使破解者难以阅读反编译的代码。

接下来分析项目如何运行起来。

![image](https://s1.ax1x.com/2018/08/13/PgQWSs.png)

这段代码表示对SplashActivity这个活动进行注册，没有在AndroidManifest.xml里注册的活动是不能使用的。其中intent-filter里的两行代码非常重要:

    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
    
这表示了SplashActivity是这个项目的主活动，即应用程序的入口。

打开HelloWorldActivity，它是继承自AppCompatActivity的，这是一种向下兼容的Acitivity，可以将Activity在各个系统版本中增加的特性和功能最低兼容到Android 2.1系统。Activity是系统提供的一个活动基类，必须继承它或者它的子类才能拥有活动的特性(AppCompatActivity是Activity的子类)。

Android程序设计为逻辑和视图分离，因此使用setContentView()的方式将对应的布局引进来。

### 详解项目中的资源

- drawable。所有以drawable开头的文件夹用来存放图片。
- mipmap。所有mipmap开头的文件夹用来存放应用图标。
- values。所有已values开头的文件夹用来存放字符串、样式、颜色等配置。
- layout。用来存放布局文件。

其中mipmap会有hdpi、xhdpi、xxhdpi等后缀，是为了适配屏幕的分辨率，从而更好地兼容各种设备，一般放在mipmap-xxhdpi下就可以了。

res/values/strings.xml文件下

    <string name="app_name">HelloWorld</string>
    
引用该字符串有两种方式：

- 代码中使用R.string.helloworld。
- XML中使用@string/hello_world。

drawble、mipmap、layout的引用与其类似。

打开AndroidManifest.xml，其中：

    android:icon="..."
    android:label="..."
    
可以看到就是使用上面的第二种引用形式来指定了项目的应用图标和应用的名称。

### 详解build.gradle文件

Gradle基于Groovy的领域特定语言(DSL)来声明项目设置。

打开工程目录下的build.gradle，其中两处repositories的闭包中都声明了jcenter()这行配置，它是一个代码托管仓库，声明它以后，就可以在项目中轻松引用任何jcenter上的开源项目了。

接下来，dependencies闭包使用了classpath声明了一个Gradle插件。声明它，AS才能使用Gradle构建Android项目，最后面试版本号，最新为3.2.0。

下面再来分析一下app目录下的build.gradle文件，第一行有两种值可选：

- com.android.application。表示这是一个应用程序模块。
- com.android.library。表示这是一个库模块。

区别为：应用程序可以直接运行，库模块智能作为代码块依附在别的应用程序模块来运行。

接下来是一个大的android闭包，用于配置项目构建的各种属性。

- compileSdkVersion。用于指定项目的编译版本。
- buildToolsVersion。用于指定项目构建工具的版本。

然后，在andorid闭包中又嵌套了一个defaultConfig闭包。

- applicaitonId。指定项目的包名。
- minSdkVersion。指定项目最低兼容的Android系统版本。
- tartgetSdkVersion。指定的值表示你在该目标版本上已经做了充分的测试，系统将会为你的应用程序启动一些最新的功能和特性。
- versionCode。指定项目的版本号。
- versionName。指定项目的版本名。

接下来，看buildTypes闭包。

- debug子闭包。指定生成测试版安装文件的配置。
- release子闭包。指定生成正式版安装文件的配置。

子闭包中。

- minifyEnabled。指定是否对项目的代码进行混淆。
- proguardFiles。指定混淆时使用的规则文件，这里指定了两个文件。
    
    1.proguard-android.txt。在Android SDK下，所有项目通用的混淆规则。
    2.proguard-rules.pro。在当前项目的根目录下，用于编写特有的混淆规则。

注意：直接运行项目生产的都是测试版安装文件。

最后，则是dependencies闭包，用于指定当前项目所有的依赖关系。通常有3钟依赖方式：

- 本地依赖。第一行的implementation fileTree就是一个本地依赖声明，表示将libs目录下的所有.jar后缀的文件都添加到项目的构建路径当中。
- 远程依赖。第二行的implementation则是远程依赖声明，其中com.android.support是域名部分，用于和其他公司的库做区分；appcompat-v7是组名称，用于和同一个公司中不同的库做区分；27.0.0是版本号，用于和同一个库中不同的版本做区分。声明后，Gradle会在构建项目时会首先检查一下本地是否已经有这个库的缓存，如果没有则会自动联网下载，然后在添加到项目的构建目录当中。
- 库依赖。新建项目默认没有这个依赖，要使用它，需要创建一个和app模块的同级模块/库,然后在使用格式compile project(':helper')，即为依赖了创建的helper库。

## 前行必备—掌握日志工具的使用

### 使用Android的日志工具Log

Android的日志工具类是Log(android.util.log)。

- Log.v()。打印最为琐碎的信息，对应级别为verbose，级别最低。
- Log.d()。打印调试信息，对应级别debug，比verbose高一级。
- Log.i()。打印重要信息，对应级别info，比debug高一级。
- Log.w()。打印警告信息，对应级别warn，比info高一级。
- Log.e()。打印错误信息，对应解绑error，比warn高一级。

    Log.d("HelloWorldActivity", "onCreate execute")；
    
Log.d()方法有两个参数，第一个是tag，一般传入当前的类名，主要对打印信息进行过滤；第二个是msg，即想要打印的具体内容。

### 为什么使用Log而不使用System.out

与Log相比，System.out的缺点如下：

- 日志打印不可控制。
- 打印时间无法控制。
- 不能添加过滤器。
- 日志没有级别区分。

Log可以使用logd快速生成模块代码，并且，在方法外面输入logt可生成tag。

除了快捷键，logcat中还能轻松添加过滤器。

- Show only selected application。只显示当前选中程序的日志。
- Firebase。谷歌的一个分析工具。
- No Filters。没有过滤器。
- Edit Filter Configuration。可以自定义过滤器，比如在log Tag一栏中填入data，一次过滤出log Tag为data的数据。

日志级别控制的好处：可以很快地找到你所关心的日志。

最后，其实我用的最多的还是关键字过滤，并且它支持正则表达式。

# 二、先从看得到的入手—探究活动

## 活动是什么

活动(Activity)是一种可以包含用户界面的组件，主要和用户进行交互，一个应用程序中可以包含零个或多个活动。

## 活动的基本用法

### 创建和加载布局

- Design切换区域是当前的可视化布局编辑器，可以预览和通过拖放的方式编辑布局。
- Text切换区域通过XML文件的方式编辑布局。

- @id/id_name。引用id对应的资源。
- @+id/id_name。定义该资源的id。
- 项目中添加的任何资源都会在R文件中生成一个相应的资源id。

### 在AndroidManifest文件中注册

- 给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器中应用程序显示的名称。

### 在活动中使用Menu

    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
    
- inflate()方法将创建的布局R.menu.main添加到系统为我们创建的menu对象中。
- 返回true允许创建的菜单显示，false菜单则无法显示。

## 使用Intent在活动之间穿梭

### 使用隐式Intent

- 只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。注意：android.intent.category.DEFAULT是一种默认的category,startActivity()调用时会自动添加。
- 每个Intent中只能指定一个action，但却能指定多个category。

### 更多隐式Intent的用法

#### 启动默认浏览器

    Intent intent = new Intent(Intent.ACTION_VIEW)；//系统内置action，打开默认浏览器
    intent.setData(Uri.parse("http://www.baidu.com"));//设置网址
    startActivity(intent)；
    
#### <data>标签

- android:scheme。指定数据的协议部分，如http。
- android：host。指定数据的主机名部分，如www.baidu.com。
- android：port。指定数据的端口部分，跟随主机名后面。
- android：path。指定主机名和端口后面的部分。
- android：mimeType。指定处理的数据类型，允许使用通配符。

注意：一般在<data>标签中不会指定过多内容。

#### 指定其他协议

除了http协议外，还可以指定很多其它协议，如geo：地理位置，tel：拨打电话。如下在程序中调用系统拨号界面。

    Intent intent = new Intent(Intent.ACTION_DIAL);//系统内置action，打开系统拨号界面
    intent.setData(Uri.parse("tel:10086"));//指定号码为10086
    startActivity(intent);
    
## 活动的生命周期

### 体验活动的生命周期

    <activity android:name=".DialogActivity"
        android:theme="@android:style/Theme.Dialog">
    </activity>
    
指定Activity为对话框样式。

### 活动被回收了怎么办

当一个活动进入到了停止状态，是有可能被系统回收的。

B->A,A返回，A不会执行onRestart()，会直接执行onCreate()，也就是重新创建一次A。

## 活动的启动模式

### A - B, B - C, 按返回键，C - A？

给B指定LauchMode为singleInstance即可。

![image](https://s1.ax1x.com/2018/08/16/PRXJET.png)

## 活动的最佳实践

### 知晓当前是在哪一个活动

在BaseActivity的onCreate()中添加：

    Log.d("BaseActivity", getClass().getSimpleName());
    
### 杀死当前程序所属的进程

    android.os.Process.killProcess(android.os.Process.myPid());

## 编写界面的最佳实践

### 制作Nine-Patch图片

它是一个被特殊处理过的png图片，能够指定哪些区域可以被拉伸、哪些区域不可以。

在图片的四个边框绘制一个个的小黑点其中：

- 上边框和左边框的部分表示当图片需要拉伸时就拉伸黑点标记的区域。
- 下边框和右边框绘制的部分表示内容会被放置的区域。

使用鼠标在图片的边缘拖动就可以进行绘制了，按住Shift键拖动可以进行擦除。

## Git创建代码仓库

Windows系统：打开Git Bash

    //配置身份
    git config --global user.name "JsonChao"
    git config --global user.email "chao.qu521@gmail.com"
    
配置完成后使用同样的命令来查看是否配置成功，只需将最后的名字和邮箱地址去掉即可。

仓库是用于保存版本管理所需信息的地方。
    
    //初始化当前文件夹为仓库
    git init
    
根目录下隐藏的.git文件夹就是用来记录本地所有的Git操作的，如果想删除本地仓库，删除.git文件夹即可。

提交本地代码

    git add build.gradle
    git add app
    git add .
    git commit -m "First commit"
    
# 三、数据存储全方案——详解持久化技术

### 将数据存储到文件中

    public void save() {
        String data = "Data to save";
        FileOutputStream out = null;
        BufferedWriter writer = null;
        try {
            //默认保存在/data/data/<packagename>/files/目录下的
            out = openFileOutput("data", Context.MODE_PRIVATE);
            writer = new BufferedWriter(new OutputStreamWriter(out));
            writer.writer(data);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
### 从文件中读取数据

    public String load() {
        FileInputStream in = null;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();
        try {
            in = openFileInput("data");
            reader = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }
    
### SharedPreferences存储

有三种方法用于得到SharedPreferences对象, SharePreferences文件都是存放在/data/data/<package name>/shared_prefs/目录下的。

- Context类中的getSharedPreferences()方法，可以任意指定其文件名。
- Activity类中的getPreferences()方法，使用当前活动的类名作为文件名。
- PreferenceManager类中的getDefaultSharedPreferences()方法，使用当前应用程序的包名作为前缀来命名文件名。

### SQLite数据库存储

#### 创建数据库

Android提供了SQLiteOpenHelper帮助类对数据库进行创建和升级，继承它，重写onCreate()和onUpgrade()方法去实现创建、升级数据库的逻辑。（数据库文件存放在/data/data/<package name>/databases/目录下）

SQLiteOpenHelper创建或打开一个现有的数据库：

- getReadableDatabase()
- getWriteableDatabase()

注意：当书记库不可写入的时候（如磁盘空间已满），getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常。

建表语句：新建一张Book表，表中有id（主键）、作者、价格、页数和书名等列。
SQLite的数据类型很简单，integer表示整形，real表示浮点型，text表示文本类型，并用autoincrement关键字表示id列是自增长的。

    create table Book (
        id integer primary key autoincrement,
        author text,
        price real,
        pages integer,
        name text)
        
在onCreate()方法中执行建表语句：

    db.execSQL(CREATE_BOOK)；
    
#### 升级数据库

当我们新添加一张表时，需要升级数据库，在onCreate()方法中多添加一条建表语句：

    db.execSQL(CREATE_BOOK);
    db.execSQL(CREATE_CATEGORY);
    
在onUpgrade()方法中添加以下代码：

    db.execSQL("drop table if exists Book");
    db.execSQL("drop table if exists Category");
    onCreate(db);
    
增加数据库版本号即可回调onUpgrade()方法重新建表：

    dbHelper = new MyDatabaseHelper(this, "BookStore.db", null, 2);
    
#### 添加数据

SQLiteDatabase中提供了一个inset()方法，第一个参数是表名，第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可。第三个参数是ContentValues对象，使用它的put()方法添加数据即可。

    SQLiteDatabase db = dbHelper.getWritableDatabase();
    ContentValues values = new ContentValues();
    //开始组装第一条数据
    values.put("name", "The Da Vinci Code");
    values.put("author", "Dan Brown");
    values.put("pages", 454);
    values.put("price", 16.96);
    db.insert("Book", null, values);//插入第一条数据
    values.clear();
    //开始组装第二条数据
    values.put("name", "The Lost Symbol");
    values.put("author", "Dan Brown");
    values.put("pages", 510);
    values.put("price", 19.95);
    db.insert("Book", null, values);//插入第二条数据
    
#### 更新数据

同理，update()方法用于对数据进行更新，第一个参数为表名，第二个参数是ContentValues对象，第三、四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。

    SQLiteDatabase db = dbHelper.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put("price", 10.99);
    db.update("Book", values, "name = ?", new String[] {"The Da Vinci Code"})；
    
第三个采纳数对应的是SQL语句的where部分，表示更新所有name等于?的行，而?是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容。

#### 删除数据

delete()方法用于删除数据，第一参数是表名，第二、三个参数用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。

    SQLiteDatabase db = dbHelper.getWriteDatabase();
    db.delete("Book", "pages > ?", new String[] {"500"});
    
#### 查询数据

query()方法用于查询数据。最短的方法重载有7个参数，第一个参数是表名，第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。第三、四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作。第六个参数用于对group by之后的数据进行进一步过滤，不指定则表示不进行过滤。第七个参数用于指定查询结果的排序方式，不指定的话则表示使用默认的排序方式。

    query()方法参数         对应SQL部分                 描述
      table             from table_name             指定查询的表名
      columns           select column1,column2      指定查询的列名
      selection         where column = value        指定where的约束条件
      selectionArgs     -                           为where中的占位符提供具体的值
      groupBy           group by colum              指定需要group by的列
      having            having column = value       对group by后的结果进一步约束
      orderBy           order by column1，column2   指定查询结果的排序方式
      
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    //查询Book表中所有的数据
    Cursor cursor = db.query("Book", null, null, null, null, null, null);
    if (cursor.moveToFirst()) {
        do {
            //遍历Cursor对象
            String name = cursor.getString(cursor.getColumnIndex("name"));
            String author = cursor.getString(cursor.getColumnIndex("author"));
            int pages = cursor.getInt(cursor.getColumnIndex("pages"));
            double price = cursor.getDouble(cursor.getColumnIndex("price"));
        } while (cursor.moveToNext());
    }
    cursor.close
    
#### 使用SQL操作数据库

- 添加数据的方法如下：

    db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)", new String[] {"The Da Vinci Code", "Dan Brown", "454", "16.96"});
    
    db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)", new String[] {"The Lost Symbol", "Dan Brown", "510", "19.95"});
    
- 更新数据的方法如下：

    db.execSQL("update Book set price = ? where name = ?", new String[] {"10.99", "The Da Vinci Code"});
    
- 删除数据的方法如下：

    db.execSQL("delete from Book where pages > ?", new String[] {"500"});
    
- 查询数据的方法如下：

    db.rawQuery("select * from Book", null);
    
# 四、跨程序共享数据——内容提供器

## 运行时权限

Android 6.0以上权限分为普通权限和危险权限。危险权限共9组24个。

注意：每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限组所对应的权限中所有的其他权限也会同时被授权。

### 在程序运行时申请权限

    if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.
        permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(MainActivity.this, new 
            String[]{Manifest.permission.CALL_PHONE}, 1)；
    } else {
        call();
    }
    
    private void call() {
        try {
            Intent intent = new Intent(Intent.ACTION_CALL);
            intent.setData(Uri.parse("tel:10086"));
            startActivity(intent);
        } catch (SecurityException e) {
            e.printStackTrace();
        }
    }
    
    @Override
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        switch (requestCode) {
            case 1:
                if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    call();
                } else {
                    Toast.makeTest(this, "You denied the permission", Toast.LENGTH_SHORT).show();
                }
                break;
            default:
                break;
        }
    }
    
